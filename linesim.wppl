/** Probabilistic model of correlated evolution of a nucleotide state and a phenotypic character
 *
 * @param start_state Integer
 *        The initial nucleotide state
 * @param start_correlated_trait_log Real on the logarithmic scale
 *        The initial state of the trait that will be co-evolving
 * @param start_independent_trait_log Real on the logarithmic scale
 *        The initial start state of a trait that evolving independently
 *        (GBM) as a control.
 * @param start_time     Start time in the past.
 *                       Will evolve till present (0)
 * @param Q              Rate matrix (for nucleotide evolution)
 * @param P              Transition probability matrix (for nucleotide evolution)
 * @param mu             Rate of molecular substitution (for nucleotide evolution)
 * @param sigma          Rate of phenotypic evolution (standard deivation, not variance!)
 *
 * @return [end_state, end_correlated_trait, end_independent_trait]
 */
var evolve = function(start_state,
                      start_correlated_trait_log,
                      start_independent_trait_log,
                      start_time,
                      Q, P, mu, sigma) {
  var S = [ [1, 2, 3],
            [0, 2, 3],
            [0, 1, 3],
            [0, 1, 2] ]
  var possible_next_states = S[start_state]
  
  // The waiting time until the transition is given by the negative
  // of the diagonal of the transition matrix
  var lambda = -mu*Q[start_state][start_state]
  var time_until_substitution = sample(Exponential({a: lambda}))
    
  if (start_time - time_until_substitution < 0) {       
    // No nucleotide substitution // The correlated trait didn't move
    var end_state = start_state 
    var end_correlated_trait_log = start_correlated_trait_log
    // The independent trait evolved (GBM, zero dift) the remaining of the time
    var trait_factor = gaussian({mu: 0,sigma: sigma*Math.sqrt(start_time)})
    var end_independent_trait_log = start_independent_trait_log + trait_factor
    return [end_state, end_correlated_trait_log, end_independent_trait_log]
  }
  
  // Nucleotide substitution
  var end_state = sample(Categorical({
    ps: P[start_state],
    vs: possible_next_states
  }))

  // The independent trait evolved (GBM, zero drift) during the time until substitution
  var trait_factor = gaussian({mu: 0,sigma: sigma*Math.sqrt(time_until_substitution)})
  var end_independent_trait_log = start_independent_trait_log + trait_factor

  // The correlated trait jumps once with the same base rate
  var trait_factor2 = gaussian({mu: 0,sigma: sigma})
  var end_correlated_trait_log = start_correlated_trait_log + trait_factor2
      
  // tail recursion
  return evolve(end_state,
                end_correlated_trait_log,
                end_independent_trait_log, 
                start_time - time_until_substitution, 
                Q, P, mu, sigma)
}

/** Jukes and Cantor 1969 Substitution Model, Scaled
 * 
 * @return Q   Transition matrix according to JC69
 */
var jc69 = function() {
  return [
    [ -1, 1/3, 1/3, 1/3 ],
    [ 1/3, -1, 1/3, 1/3 ],
    [ 1/3, 1/3, -1, 1/3 ],
    [ 1/3, 1/3, 1/3, -1 ] ]
}

/** Hasegawa, Kishino and Yano 1985
 *
 * @param p  A vector of base frequencies (length 4)
 * @param k  kappa parameter
 *
 * @return scaled Q matrix
 */
var hky85 = function(p, k) {
  var f = 1/(2*(p[0] + p[2])*(p[1] + p[3]) + 2*k*(p[0]*p[2] + p[1]*p[3]))
  var Q = [ 
      [ -f*(p[1] + k*p[2] + p[3]), f*p[1], f*k*p[2], f*p[3] ] ,
      [ f*p[0], -f*(p[0] + p[2] + k*p[3]) , f*p[2] , f*k*p[3] ] ,
      [ f*k*p[0], f*p[1], -f*(k*p[0] + p[1] + p[3]), f*p[3] ],
      [ f*p[0], f*k*p[1] , f*p[2] , -f*(p[0] + k*p[1] + p[2]) ] 
    ]
  return Q
}

/** Generalized Time-Reversible
 * 
 * The rates frequency vector encodes the transitions as follows
 *   r[0] : A -> C (alpha) 0 -> 1
 *   r[1] : A -> G (beta)  0 -> 2
 *   r[2] : A -> T (gamma) 0 -> 3
 *   r[3] : C -> G (delta) 1 -> 2
 *   r[4] : C -> T (eta)   1 -> 3
 *   r[5] : G -> T (nu)    2 -> 3
 
 *
 * @param p  Base frequency vector (length 4)
 * @param r  Rates vector (length 6)
 *
 * @return Q   Transition matrix
 */
var gtr = function(p, r) {
 var Q = [
  [ -(r[0]*p[1] + r[1]*p[2] + r[2]*p[3]), r[0]*p[1], r[1]*p[2], r[2]*p[3] ],
  [ r[0]*p[0], -(r[0]*p[0] + r[3]*p[2] + r[4]*p[3]), r[3]*p[2], r[4]*p[3] ],
  [ r[1]*p[0], r[3]*p[1], -(r[1]*p[0] + r[3]*p[1] + r[5]*p[3]), r[5]*p[3] ],
  [ r[2]*p[0], r[4]*p[1], r[5]*p[2], -(r[2]*p[0] + r[4]*p[1] + r[5]*p[2]) ] 
]
 var f = -1/(p[0]*Q[0][0] + p[1]*Q[1][1] * p[2]*Q[2][2] + p[3]*Q[3][3])
 return [ 
  [ f*Q[0][0], f*Q[0][1], f*Q[0][2], f*Q[0][3] ],
  [ f*Q[1][0], f*Q[1][1], f*Q[1][2], f*Q[1][3] ],
  [ f*Q[2][0], f*Q[2][1], f*Q[2][2], f*Q[2][3] ],
  [ f*Q[3][0], f*Q[3][1], f*Q[3][2], f*Q[3][3] ] ] 
}

/** Calculate transition probabilities
* 
* 
* @param Q  Rate matrix
* 
* @return   A matrix encoding the transition probabilities
*           from one state to another 
*/
var transition_probabilities = function(Q) {
  var P = [ 
    [-Q[0][1]/Q[0][0], -Q[0][2]/Q[0][0], -Q[0][3]/Q[0][0] ],
    [-Q[1][0]/Q[1][1], -Q[1][2]/Q[1][1], -Q[1][3]/Q[1][1] ],
    [-Q[2][0]/Q[2][2], -Q[2][1]/Q[2][2], -Q[2][3]/Q[2][2] ],
    [-Q[3][0]/Q[3][3], -Q[3][1]/Q[3][3], -Q[3][2]/Q[3][3] ] 
  ]
  return P
}

// Nucleotides: A, C, G, T  // States: 0, 1, 2, 3 TODO Validate vs AGCT encoding
var nucleotides = ["A", "C", "G", "T"]

// var start_state = sample(Categorical({ps: [0.25, 0.25, 0.25, 0.25], vs: [0, 1, 2, 3] }))	
var start_nucleotide = "A"
var start_state = nucleotides.indexOf(start_nucleotide)

// We also have the two traits starting together at 1.0
var start_independent_trait = 1.0
var start_correlated_trait = 1.0

// Setup the instantaneous rate matrix
// equal base frequencies and equal rates
// var Q = gtr([1/4, 1/4, 1/4, 1/4],
//             [1, 1, 1, 1, 1, 1]) 

// Simplest model
var Q = jc69()
// Transition probability matrix is computed from the instantenous rate matrix
var P = transition_probabilities(Q)

var time = 10    // time units
var sigma2 = 1 // A value of 0.1 means that after 10 time units, we will add to
             // the logarithm of the trait evolving according to GBM a factor
             // sampled from N(0, 1)
             // N(0, sigma2*time)
var mu = 5 // substitutions per site per time unit
             // this means that for 10 time units we will see an average 10
             // subsititutions from the starting nucleotide, thus to log of the 
             // correlated trait we will add a factor sampled from N(0, 10) (on average)
             // N(0, mu*time)

var model = function() {
  // Run the simulation 
  var end_states = evolve(
    start_state,
    Math.log(start_correlated_trait),
    Math.log(start_independent_trait),
    time,
    Q, P, mu, Math.sqrt(sigma2)
  )
  return end_states
}

var dist = Infer({
  method: 'SMC',
  particles: 100,
  model: model
})

JSON.stringify(dist.samples)
// Expected that var(correlated trait ) ~= 10*var(independent trait)