/** Probabilistic model of correlated evolution of a nucleotide state and a phenotypic character
 *
 * @param start_state Integer
 *        The initial nucleotide state
 * @param start_correlated_trait_log Real on the logarithmic scale
 *        The initial state of the trait that will be co-evolving
 * @param start_independent_trait_log Real on the logarithmic scale
 *        The initial start state of a trait that evolving independently
 *        (GBM) as a control.
 * @param start_time     Start time in the past.
 *                       Will evolve till present (0)
 * @param Q              Rate matrix (for nucleotide evolution)
 * @param P              Transition probability matrix (for nucleotide evolution)
 * @param mu             Rate of molecular substitution (for nucleotide evolution)
 * @param sigma          Rate of phenotypic evolution (standard deivation, not variance!)
 *
 * @return [end_state, end_correlated_trait, end_independent_trait]
 */
var evolve = function(start_state,
                      start_correlated_trait_log,
                      start_independent_trait_log,
                      start_time,
                      Q, P, mu, sigma) {
  var S = [ [1, 2, 3],
            [0, 2, 3],
            [0, 1, 3],
            [0, 1, 2] ]
  var possible_next_states = S[start_state]
  
  // The waiting time until the transition is given by the negative
  // of the diagonal of the transition matrix
  var lambda = -mu*Q[start_state][start_state]
  var time_until_substitution = sample(Exponential({a: lambda}))
    
  if (start_time - time_until_substitution < 0) {       
    var end_state = start_state // No nucleotide substitution

    // The correlated trait didn't move
    var end_correlated_trait_log = start_correlated_trait_log

    // The independent trait evolved (GBM, zero dift) the remaining of the time
    var trait_factor = gaussian({mu: 0,sigma: sigma*Math.sqrt(start_time)})
    var end_independent_trait_log = start_independent_trait_log + trait_factor
    
    return [end_state, end_correlated_trait_log, end_independent_trait_log]
  }
  
  // Nucleotide substitution
  var end_state = sample(Categorical({
    ps: P[start_state],
    vs: possible_next_states
  }))

  // The independent trait evolved (GBM, zero drift) during the time until substitution
  var trait_factor = gaussian({mu: 0,sigma: sigma*Math.sqrt(time_until_substitution)})
  var end_independent_trait_log = start_independent_trait_log + trait_factor

  // The correlated trait jumps once with the same base rate
  var trait_factor2 = gaussian({mu: 0,sigma: sigma})
  var end_correlated_trait_log = start_correlated_trait_log + trait_factor2
      
  // tail recursion
  return evolve(end_state,
                end_correlated_trait_log,
                end_independent_trait_log, 
                start_time - time_until_substitution, 
                Q, P, mu, sigma)
}

/** Jukes and Cantor 1969 Substitution Model, Scaled
 * 
 * @return Q   Transition matrix according to JC69
 */
var jc69 = function() {
  return [
    [ -1, 1/3, 1/3, 1/3 ],
    [ 1/3, -1, 1/3, 1/3 ],
    [ 1/3, 1/3, -1, 1/3 ],
    [ 1/3, 1/3, 1/3, -1 ] ]
}

/**
 * Jukes-Cantor for a n-character state matrix
 * 
 * The instantaneous rates for any transition are the same.
 * 
 * @param n The number of states
 * 
 * @return Q Transition matrix
 */

var jc_character = function(n) {
  var rowf = function(row) {
      return mapN(function(col) { 
        if (col == row) {
          return -1
        } else return 1/(n-1)
      },
      n)
  }
  var Q = mapN(rowf, n)

  return Q
}

/** Hasegawa, Kishino and Yano 1985
 *
 * @param p  A vector of base frequencies (length 4)
 * @param k  kappa parameter
 *
 * @return scaled Q matrix
 */
var hky85 = function(p, k) {
  var f = 1/(2*(p[0] + p[2])*(p[1] + p[3]) + 2*k*(p[0]*p[2] + p[1]*p[3]))
  var Q = [ 
      [ -f*(p[1] + k*p[2] + p[3]), f*p[1], f*k*p[2], f*p[3] ] ,
      [ f*p[0], -f*(p[0] + p[2] + k*p[3]) , f*p[2] , f*k*p[3] ] ,
      [ f*k*p[0], f*p[1], -f*(k*p[0] + p[1] + p[3]), f*p[3] ],
      [ f*p[0], f*k*p[1] , f*p[2] , -f*(p[0] + k*p[1] + p[2]) ] 
    ]
  return Q
}

/** Generalized Time-Reversible
 * 
 * The rates frequency vector encodes the transitions as follows
 *   r[0] : A -> C (alpha) 0 -> 1
 *   r[1] : A -> G (beta)  0 -> 2
 *   r[2] : A -> T (gamma) 0 -> 3
 *   r[3] : C -> G (delta) 1 -> 2
 *   r[4] : C -> T (eta)   1 -> 3
 *   r[5] : G -> T (nu)    2 -> 3
 
 *
 * @param p  Base frequency vector (length 4)
 * @param r  Rates vector (length 6)
 *
 * @return Q   Transition matrix
 */
var gtr = function(p, r) {
 var Q = [
  [ -(r[0]*p[1] + r[1]*p[2] + r[2]*p[3]), r[0]*p[1], r[1]*p[2], r[2]*p[3] ],
  [ r[0]*p[0], -(r[0]*p[0] + r[3]*p[2] + r[4]*p[3]), r[3]*p[2], r[4]*p[3] ],
  [ r[1]*p[0], r[3]*p[1], -(r[1]*p[0] + r[3]*p[1] + r[5]*p[3]), r[5]*p[3] ],
  [ r[2]*p[0], r[4]*p[1], r[5]*p[2], -(r[2]*p[0] + r[4]*p[1] + r[5]*p[2]) ] 
]
 var f = -1/(p[0]*Q[0][0] + p[1]*Q[1][1] * p[2]*Q[2][2] + p[3]*Q[3][3])
 return [ 
  [ f*Q[0][0], f*Q[0][1], f*Q[0][2], f*Q[0][3] ],
  [ f*Q[1][0], f*Q[1][1], f*Q[1][2], f*Q[1][3] ],
  [ f*Q[2][0], f*Q[2][1], f*Q[2][2], f*Q[2][3] ],
  [ f*Q[3][0], f*Q[3][1], f*Q[3][2], f*Q[3][3] ] ] 
}

/** 
  * Calculate transition probabilities
  * 
  * This function only works for 4x4 state matrices,
  * but is probably faster than the general case function
  * transition_probabilities_n(Q).
  * 
  * @param Q  Rate matrix
  * 
  * @return   A matrix encoding the transition probabilities
  *           from one state to another 
  */
var transition_probabilities = function(Q) {
  var P = [ 
    [-Q[0][1]/Q[0][0], -Q[0][2]/Q[0][0], -Q[0][3]/Q[0][0] ],
    [-Q[1][0]/Q[1][1], -Q[1][2]/Q[1][1], -Q[1][3]/Q[1][1] ],
    [-Q[2][0]/Q[2][2], -Q[2][1]/Q[2][2], -Q[2][3]/Q[2][2] ],
    [-Q[3][0]/Q[3][3], -Q[3][1]/Q[3][3], -Q[3][2]/Q[3][3] ] 
  ]
  return P
}

/** 
 * Calculate transition probabilities from any square matrix Q
 * n x n
 * 
 * @param Q  Rate matrix
 * @return Transition probabilities matrix n x (n-1),
 *         each row encodes the transition probabilities
 *         to the other n - 1 states
*/
var transition_probabilities_n = function(Q) {
  var P = mapN(
    function(row) {
      var r = mapN(
        function(col) {
          return -Q[row][col]/Q[row][row]
        },
        Q.length
      )
      filter(function(e) {
        return e != -1
      }, r)
    }, 
    Q.length
  )
  return P
}